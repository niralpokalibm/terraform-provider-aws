# `include_resource = false` Performance Audit

## Background

Terraform Query list blocks support an `include_resource` flag. When `false` (the default),
only resource **identities** — ID, ARN, name — are needed. When `true`, the full resource
state is returned.

Many list resource implementations call a full `resource*Read` or `find*` function
**unconditionally before `SetResult`**, executing expensive AWS API calls even when the
results are discarded. `SetResult(..., request.IncludeResource, ...)` only gates writing
the resource body to output — it does **not** prevent API calls made before it.

### The bug pattern

```go
// ❌ BROKEN — extra API calls run even when include_resource = false
rd.SetId(bucketName)
diags := resourceBucketRead(ctx, rd, l.Meta())  // 14 API calls, always runs
l.SetResult(ctx, l.Meta(), request.IncludeResource, &result, rd)

// ✅ FIXED
rd.SetId(bucketName)
rd.Set("bucket", bucketName)  // identity from list response
if request.IncludeResource {
    diags := resourceBucketRead(ctx, rd, l.Meta())
}
l.SetResult(ctx, l.Meta(), request.IncludeResource, &result, rd)
```

### How list block resources were found

List block resources carry a codegen annotation generated by `skaff list`:

```bash
grep -rl "@SDKListResource\|@FrameworkListResource" internal/service --include="*.go" | sort
```

The parent resource file carries `@IdentityAttribute(...)` annotations that define the
minimum fields required in all modes (even `include_resource = false`). These were checked
against the list API response to confirm all identity fields are available without extra calls.

Reference guide: https://hashicorp.github.io/terraform-provider-aws/add-a-new-list-resource/

---

## Audit Results

**48 total list resources. 30 need fixing. 18 are already correct.**

---

### ❌ 30 Resources — Extra API calls regardless of `include_resource`

| Resource | Extra Calls | AWS API(s) Called |
|---|:---:|---|
| `aws_s3_bucket` | **14** | `HeadBucket`, `GetBucketPolicy`, `GetBucketAcl`, `GetBucketCors`, `GetBucketWebsite`, `GetBucketVersioning`, `GetBucketAccelerateConfiguration`, `GetBucketRequestPayment`, `GetBucketLogging`, `GetBucketLifecycleConfiguration`, `GetBucketReplication`, `GetBucketEncryption`, `GetObjectLockConfiguration`, `HeadBucket` (region) |
| `aws_instance` | **4–8** | `DescribeInstanceTypes`, `DescribeInstanceAttribute` ×2; +up to 4 more if launch template exists |
| `aws_vpc` | **6** | `DescribeVpcAttribute` ×3 (DNS settings), `DescribeNetworkAcls`, `DescribeRouteTables`, `DescribeSecurityGroups` |
| `aws_kms_key` | **3–4** | `DescribeKey`, `GetKeyPolicy`, `ListResourceTags`; +`GetKeyRotationStatus` conditionally |
| `aws_lambda_function` | **2–3** | `GetFunction`, `ListVersionsByFunction`; +`GetFunctionCodeSigningConfig` conditionally |
| `aws_route53_record` | **2** | `GetHostedZone`, `ListResourceRecordSets` (both redundant — already in list response) |
| `aws_cleanrooms_collaboration` | **2** | `GetCollaboration`, `ListMembers` |
| `aws_secretsmanager_secret` | **2** | `DescribeSecret`, `GetResourcePolicy` |
| `aws_ssm_parameter` | **2** | `GetParameter`, `DescribeParameters` (redundant — list already called it) |
| `aws_appflow_flow` | **1** | `DescribeFlow` |
| `aws_cleanrooms_configured_table` | **1** | `GetConfiguredTable` |
| `aws_cloudfront_key_value_store` | **1** | `DescribeKeyValueStore` |
| `aws_cloudwatch_event_rule` | **1** | `DescribeRule` |
| `aws_codebuild_project` | **1** | `BatchGetProjects` |
| `aws_ecs_task_definition` | **1** | `DescribeTaskDefinition` |
| `aws_iam_role_policy` | **1** | `GetRolePolicy` |
| `aws_lambda_permission` | **~0/item** | `GetPolicy` once per function (enumeration mechanism — see notes) |
| `aws_opensearchserverless_collection` | **1** | `BatchGetCollection` |
| `aws_route` | **1** | `DescribeRouteTables` (redundant — already fetched by list) |
| `aws_route_table` | **1** | `DescribeRouteTables` (redundant — already fetched by paginator) |
| `aws_route53_resolver_rule_association` | **1** | `GetResolverRuleAssociation` (redundant — already in paginator result) |
| `aws_s3_bucket_lifecycle_configuration` | **1** | `GetBucketLifecycleConfiguration` |
| `aws_s3_bucket_policy` | **1** | `GetBucketPolicy` |
| `aws_s3_bucket_public_access_block` | **1** | `GetPublicAccessBlock` |
| `aws_s3_bucket_server_side_encryption_configuration` | **1** | `GetBucketEncryption` |
| `aws_s3_directory_bucket` | **1** | `HeadBucket` (redundant — already known from `ListDirectoryBuckets`) |
| `aws_s3_object` | **1** | `HeadObject` |
| `aws_secretsmanager_secret_version` | **1–2** | `GetSecretValue`; +`ListSecretVersionIds` conditionally |
| `aws_security_group` | **1** | `DescribeSecurityGroups` (redundant — data already in paginator) |
| `aws_sqs_queue` | **1** | `GetQueueAttributes` |

---

### ✅ 18 Resources — Already correct

These either flatten identity directly from the list API response, or explicitly guard
extra calls with `if request.IncludeResource { ... }`.

| Resource | Extra Calls | How |
|---|:---:|---|
| `aws_appflow_connector_profile` | **0** | Inline from `DescribeConnectorProfiles` |
| `aws_batch_job_definition` | **0** | Inline from `DescribeJobDefinitions` |
| `aws_batch_job_queue` | **0** | Inline from `DescribeJobQueues` |
| `aws_cloudwatch_event_target` | **0** | Inline from `ListTargetsByRule` |
| `aws_cloudwatch_log_group` | **0** | Inline from `DescribeLogGroups` |
| `aws_cloudwatch_metric_alarm` | **0** | Inline from `DescribeAlarms` |
| `aws_ec2_secondary_network` | **0** | Inline from `DescribeSecondaryNetworks` |
| `aws_ec2_secondary_subnet` | **0** | Inline from `DescribeSecondarySubnets` |
| `aws_ecr_repository` | **0** | Inline from `DescribeRepositories` |
| `aws_iam_policy` | **0** | `GetPolicyVersion` guarded by `if request.IncludeResource` ✅ |
| `aws_iam_role` | **0** | Inline from `ListRoles` |
| `aws_iam_role_policy_attachment` | **0** | Inline from `ListAttachedRolePolicies` |
| `aws_kms_alias` | **0** | Inline from `ListAliases` |
| `aws_lambda_capacity_provider` | **0** | Inline from `ListCapacityProviders` |
| `aws_s3_bucket_acl` | **0** | `GetBucketAcl` guarded by `if request.IncludeResource` ✅ |
| `aws_subnet` | **0** | Inline from `DescribeSubnets` |
| `aws_vpc_security_group_egress_rule` | **0** | Inline from `DescribeSecurityGroupRules` |
| `aws_vpc_security_group_ingress_rule` | **0** | Inline from `DescribeSecurityGroupRules` |

---

## Can All 30 Be Fixed Without Extra API Calls?

**Yes.** Every `@IdentityAttribute` field required for resource identity is available
directly from the list API response. No additional AWS calls are needed to return identity
when `include_resource = false`.

The 30 resources fall into three groups:

### Group A — 23 resources: Identity already set, just wrap the extra call

These resources already set all required identity fields before the extra API call.
The only change needed is adding `if request.IncludeResource { ... }` around it.

```
aws_appflow_flow, aws_cleanrooms_collaboration, aws_cleanrooms_configured_table,
aws_codebuild_project, aws_instance, aws_kms_key, aws_lambda_function,
aws_route, aws_route_table, aws_route53_record, aws_route53_resolver_rule_association,
aws_s3_bucket, aws_s3_bucket_lifecycle_configuration, aws_s3_bucket_policy,
aws_s3_bucket_public_access_block, aws_s3_bucket_server_side_encryption_configuration,
aws_s3_directory_bucket, aws_s3_object, aws_secretsmanager_secret,
aws_secretsmanager_secret_version, aws_security_group, aws_sqs_queue, aws_vpc
```

### Group B — 6 resources: One missing field assignment (data already in list response)

These need one additional `rd.Set(...)` / `data.Field = ...` line added before the guard,
using a variable already in scope. No extra API call required.

| Resource | Missing field | Fix |
|---|---|---|
| `aws_cloudwatch_event_rule` | `name` | Add `rd.Set("name", name)` — `name` var already exists |
| `aws_cloudfront_key_value_store` | `name` | Add `data.Name = fwflex.StringToFramework(ctx, item.Name)` |
| `aws_ecs_task_definition` | `family`, `revision` | Parse from ARN string (e.g. `.../family:revision`) — pure string split |
| `aws_iam_role_policy` | `role`, `name` | Add `rd.Set("role", roleName)` + `rd.Set("name", policyName)` — both vars in scope |
| `aws_opensearchserverless_collection` | `id` | Add `data.ID = fwflex.StringToFramework(ctx, collectionSummary.Id)` |
| `aws_ssm_parameter` | `name` | Add `rd.Set("name", name)` — `name` var already exists |

### Group C — 1 resource: Special case

`aws_lambda_permission` — `GetPolicy` is the enumeration mechanism itself (the permission
list is parsed from the policy JSON). All identity fields are set inline per statement.
Effectively 0 extra calls per permission item. Low priority.

---

## Fix Pattern

Use `aws_s3_bucket_acl` (`internal/service/s3/bucket_acl_list.go`) and
`aws_iam_policy` (`internal/service/iam/policy_list.go`) as reference implementations.

```go
// Step 1: Set identity fields from list response (always runs, even when include_resource=false)
rd.SetId(bucketName)
rd.Set("bucket", bucketName)

// Step 2: Guard the expensive API call
if request.IncludeResource {
    diags := resourceBucketRead(ctx, rd, l.Meta())
    if diags.HasError() {
        // handle...
    }
}

// Step 3: SetResult — identity always present; resource body only if includeResource=true
l.SetResult(ctx, l.Meta(), request.IncludeResource, &result, rd)
```

**Rule:** All `@IdentityAttribute` fields from the parent resource file must be populated
**before** the `if request.IncludeResource` guard, using data from the list response only.

---

## Implementation Priority

| Priority | Resources | Reason |
|---|---|---|
| **P1** | `aws_s3_bucket`, `aws_instance`, `aws_vpc`, `aws_kms_key` | 3–14 extra calls per item |
| **P2** | `aws_route53_record`, `aws_cleanrooms_collaboration`, `aws_secretsmanager_secret`, `aws_ssm_parameter`, `aws_lambda_function` | 2+ calls or widely used |
| **P3** | All remaining Group A resources | Mechanical 1-line guard |
| **P4** | Group B resources | 1-line identity field + guard |
| **P5** | `aws_lambda_permission` | Amortized cost, lower impact |

---

## Notable Observations

- **`aws_s3_bucket`** is the worst offender: **14 extra calls per bucket**, running the
  entire `resourceBucketRead` path unconditionally.

- **Redundant calls** — these resources call an API that was already called during
  enumeration, fetching the same data twice:
  `aws_route`, `aws_route_table`, `aws_security_group`, `aws_route53_resolver_rule_association`,
  `aws_ssm_parameter`, `aws_s3_directory_bucket`, `aws_route53_record`, `aws_vpc`

- **Hidden API calls in flatten functions** — `resourceVPCFlatten` and `resourceInstanceFlatten`
  make API calls internally. These were initially classified as clean because the function
  name suggests in-memory work. Always grep flatten function bodies for `conn.` / `find[A-Z]`.

- **`aws_lambda_permission`** — `GetPolicy` is the enumeration mechanism itself. Permissions
  are extracted from the policy JSON per function, so there are 0 extra calls per permission
  item. This is by design.
